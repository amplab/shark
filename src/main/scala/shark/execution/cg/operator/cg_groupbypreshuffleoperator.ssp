<% escapeMarkup = false %>
#import(shark.execution.GroupByPreShuffleOperator)
#import(shark.execution.cg.row.CGStruct)
#import(shark.execution.cg.operator.CGOperator)
<%@ import val cgo: CGOperator %>
<%@ import val op: GroupByPreShuffleOperator %>
#{
  val structClassName = row.fullClassName
}#

package ${packageName};

import java.io.Serializable;
import java.util.Random;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.hadoop.hive.ql.exec.ExprNodeEvaluator;
import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;
import org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator;
import org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator.AggregationBuffer;
import org.apache.hadoop.hive.ql.exec.KeyWrapper;
import org.apache.hadoop.hive.ql.exec.KeyWrapperFactory;

import shark.execution.cg.OperatorExecutor;
import shark.execution.GroupByPreShuffleOperator;

public class ${className} implements OperatorExecutor, Serializable {
  private static final long serialVersionUID = 1L;
  private ObjectInspector rowInspector;
  private KeyWrapperFactory keyFactory;
#for(i <- 0 until aggregationEvals.length)
  private GenericUDAFEvaluator aggregationEval${i};
  private ObjectInspector aggregationObjectInspector${i};
  private ExprNodeEvaluator[] aggregationParameterField${i};
#end
#for(i <- 0 until currentKeyObjectInspectors.length)
  private ObjectInspector keyObjectInspector${i};
#end
  public ${className}(Object obj) {
    GroupByPreShuffleOperator o = (GroupByPreShuffleOperator)obj;
    this.rowInspector = o.rowInspector();
    this.keyFactory = o.keyFactory();
#for(i <- 0 until aggregationEvals.length)
    this.aggregationEval${i} = o.aggregationEvals()[${i}];
    this.aggregationObjectInspector${i} = o.aggregationObjectInspectors()[${i}];
    this.aggregationParameterField${i} = o.aggregationParameterFields()[${i}];
#end
#for(i <- 0 until currentKeyObjectInspectors.length)
    this.keyObjectInspector${i} = o.currentKeyObjectInspectors()[${i}];
#end
  }
  
  public Object evaluate(Object obj) throws Exception {
    final HashMap<KeyWrapper, AggregationBuffer[]> hashAggregations = new HashMap<KeyWrapper, AggregationBuffer[]>();
    final KeyWrapper newKeys = keyFactory.getKeyWrapper();
    scala.collection.Iterator<?> iter = (scala.collection.Iterator<?>)obj;
    try {
    while(iter.hasNext()) {
      Object row = iter.next();
      newKeys.getNewKey(row, rowInspector);
      newKeys.setHashKey();
      
      AggregationBuffer[] aggs = hashAggregations.get(newKeys);
      if(aggs == null) {
//        aggs = newAggregations()
//        protected def newAggregations(): Array[AggregationBuffer] = {
//            aggregationEvals.map(eval => eval.getNewAggregationBuffer)
//        }

        aggs = new AggregationBuffer[${aggregationEvals.length}];
#for(i <- 0 until aggregationEvals.length)
        {
          aggs[${i}] = aggregationEval${i}.getNewAggregationBuffer();
          hashAggregations.put(newKeys.copyKey(), aggs);
          Object[] parameters = new Object[aggregationParameterField${i}.length];
    #for(a <- 0 until aggregationParameterFields(i).length)
          parameters[${a}] = aggregationParameterField${i}[${a}].evaluate(row);
    #end
          aggregationEval${i}.aggregate(aggs[${i}], parameters);
        }
#end
//      aggregateNewKey(row, aggs)
//        def aggregateNewKey(row: Object, aggregations: Array[AggregationBuffer]) {
//          var i = 0
//          while (i < aggregations.length) {
//            aggregationEvals(i).aggregate(
//              aggregations(i), aggregationParameterFields(i).map(_.evaluate(row)))
//            i += 1
//          }
//        }        
      } else {
//      aggregateExistingKey(row, aggs)
//        @inline protected final
//        def aggregateExistingKey(row: AnyRef, aggregations: Array[AggregationBuffer]) {
//          var i = 0
//          while (i < aggregations.length) {
//            if (!aggregationIsDistinct(i)) {
//              aggregationEvals(i).aggregate(
//                aggregations(i), aggregationParameterFields(i).map(_.evaluate(row)))
//            }
//            i += 1
//          }
//        }
#for(i <- 0 until aggregationEvals.length)
    #if(!aggregationIsDistinct(i))
        {
          Object[] parameters = new Object[aggregationParameterField${i}.length];
	#for(a <- 0 until aggregationParameterFields(i).length)
          parameters[${a}] = aggregationParameterField${i}[${a}].evaluate(row);
    #end
          
          aggregationEval${i}.aggregate(aggs[${i}], parameters);
        }
    #end
#end
      }
    }
    } catch (Throwable t) {
      t.printStackTrace();
    }

    return new java.util.Iterator<Object>() {
      java.util.Iterator<Entry<KeyWrapper, AggregationBuffer[]>> it = hashAggregations.entrySet().iterator();
      public boolean hasNext() {
        return it.hasNext();
      }
      public void remove() {throw new UnsupportedOperationException("remove");}
      public Object next() {
      try{
        ${structClassName} data = new ${structClassName}();
        
        Map.Entry<KeyWrapper, AggregationBuffer[]> pair = (Map.Entry<KeyWrapper, AggregationBuffer[]>)it.next();
        Object[] keyAttr = pair.getKey().getKeyArray();
#for(i <- 0 until currentKeyObjectInspectors.length)
        if (keyAttr[${i}] != null) {
          data.mask.set(${structClassName}.MASK_${row.fields(i).name}, true);
          ${row.fields(i).getValue("data." + row.fields(i).name, "keyObjectInspector" + i, "keyAttr[" + i + "]")}
        }
#end
        AggregationBuffer[] aggrs = pair.getValue();
#for(i <- 0 until aggregationEvals.length)
        if (aggrs[${i}] != null) {
          data.mask.set(${structClassName}.MASK_${row.fields(i + currentKeyObjectInspectors.length).name}, true);
          Object obj = aggregationEval${i}.evaluate(aggrs[${i}]);
          ${row.fields(i + currentKeyObjectInspectors.length).getValue("data." + row.fields(i + currentKeyObjectInspectors.length).name, "aggregationObjectInspector" + i, "obj")}
        }
#end
        return data;
        } catch (Throwable e) {
          e.printStackTrace();
          throw new RuntimeException(e);
        }
      }
    };
  }
}